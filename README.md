# scope-tasks    (https://learn.javascript.ru/closures)
задачки
Всегда текущее значение
Значение переменной из внешней области берётся всегда текущее. Оно может быть уже не то, что было на момент создания функции.

Например, в коде ниже функция sayHi берёт phrase из внешней области:

    var phrase = 'Привет';

    function sayHi(name) {
      alert(phrase + ', ' + name);
    }

    sayHi('Вася');  // Привет, Вася (*)

    phrase = 'Пока';

    sayHi('Вася'); // Пока, Вася (**)
На момент первого запуска (*), переменная phrase имела значение 'Привет', а ко второму (**) изменила его на 'Пока'.

Это естественно, ведь для доступа к внешней переменной функция по ссылке [[Scope]] обращается во внешний объект переменных и берёт то значение, которое там есть на момент обращения.

Вложенные функции
Внутри функции можно объявлять не только локальные переменные, но и другие функции.

К примеру, вложенная функция может помочь лучше организовать код:

 

    function sayHiBye(firstName, lastName) {

      alert( "Привет, " + getFullName() );
      alert( "Пока, " + getFullName() );

      function getFullName() {
        return firstName + " " + lastName;
      }

    }

    sayHiBye("Вася", "Пупкин"); // Привет, Вася Пупкин ; Пока, Вася Пупкин
Здесь, для удобства, создана вспомогательная функция getFullName().

Вложенные функции получают [[Scope]] так же, как и глобальные. В нашем случае:

getFullName.[[Scope]] = объект переменных текущего запуска sayHiBye
Благодаря этому getFullName() получает снаружи firstName и lastName.

Заметим, что если переменная не найдена во внешнем объекте переменных, то она ищется в ещё более внешнем (через [[Scope]] внешней функции), то есть, такой пример тоже будет работать:

     var phrase = 'Привет';

    function say() {

      function go() {
        alert( phrase ); // найдёт переменную снаружи
      }

      go();
    }

    say();
Возврат функции
Рассмотрим более «продвинутый» вариант, при котором внутри одной функции создаётся другая и возвращается в качестве результата.

В разработке интерфейсов это совершенно стандартный приём, функция затем может назначаться как обработчик действий посетителя.

Здесь мы будем создавать функцию-счётчик, которая считает свои вызовы и возвращает их текущее число.

В примере ниже makeCounter создает такую функцию:

 

    function makeCounter() {
      var currentCount = 1;

      return function() { // (**)
        return currentCount++;
      };
    }

    var counter = makeCounter(); // (*)

    // каждый вызов увеличивает счётчик и возвращает результат
    alert( counter() ); // 1
    alert( counter() ); // 2
    alert( counter() ); // 3

    // создать другой счётчик, он будет независим от первого
    var counter2 = makeCounter();
    alert( counter2() ); // 1
Как видно, мы получили два независимых счётчика counter и counter2, каждый из которых незаметным снаружи образом сохраняет текущее количество вызовов.

Где? Конечно, во внешней переменной currentCount, которая у каждого счётчика своя.

Если подробнее описать происходящее:

В строке (*) запускается makeCounter(). При этом создаётся LexicalEnvironment для переменных текущего вызова. В функции есть одна переменная var currentCount, которая станет свойством этого объекта. Она изначально инициализуется в undefined, затем, в процессе выполнения, получит значение 1:


    function makeCounter() {
      // LexicalEnvironment = { currentCount: undefined }

      var currentCount = 1;

      // LexicalEnvironment = { currentCount: 1 }

      return function() { // [[Scope]] -> LexicalEnvironment (**)
        return currentCount++;
      };
    }

var counter = makeCounter(); // (*)
В процессе выполнения makeCounter() создаёт функцию в строке (**). При создании эта функция получает внутреннее свойство [[Scope]] со ссылкой на текущий LexicalEnvironment.

Далее вызов makeCounter() завершается и функция (**) возвращается и сохраняется во внешней переменной counter (*).

На этом создание «счётчика» завершено.

Итоговым значением, записанным в переменную counter, является функция:

    function() { // [[Scope]] -> {currentCount: 1}
      return currentCount++;
    };
Возвращённая из makeCounter() функция counter помнит (через [[Scope]]) о том, в каком окружении была создана.

Это и используется для хранения текущего значения счётчика.

Далее, когда-нибудь, функция counter будет вызвана. Мы не знаем, когда это произойдёт. Может быть, прямо сейчас, но, вообще говоря, совсем не факт.

Эта функция состоит из одной строки: return currentCount++, ни переменных ни параметров в ней нет, поэтому её собственный объект переменных, для краткости назовём его LE – будет пуст.

Однако, у неё есть свойство [[Scope]], которое указывает на внешнее окружение. Чтобы увеличить и вернуть currentCount, интерпретатор ищет в текущем объекте переменных LE, не находит, затем идёт во внешний объект, там находит, изменяет и возвращает новое значение:

       function makeCounter() {
        var currentCount = 1;

        return function() {
          return currentCount++;
        };
      }

      var counter = makeCounter(); // [[Scope]] -> {currentCount: 1}

      alert( counter() ); // 1, [[Scope]] -> {currentCount: 1}
      alert( counter() ); // 2, [[Scope]] -> {currentCount: 2}
      alert( counter() ); // 3, [[Scope]] -> {currentCount: 3}
Переменную во внешней области видимости можно не только читать, но и изменять.

В примере выше было создано несколько счётчиков. Все они взаимно независимы:

    var counter = makeCounter();
    var counter2 = makeCounter();

    alert( counter() ); // 1
    alert( counter() ); // 2
    alert( counter() ); // 3

alert( counter2() ); // 1, счётчики независимы
Они независимы, потому что при каждом запуске makeCounter создаётся свой объект переменных LexicalEnvironment, со своим свойством currentCount, на который новый счётчик получит ссылку [[Scope]].

Свойства функции
Функция в JavaScript является объектом, поэтому можно присваивать свойства прямо к ней, вот так:

     function f() {}

    f.test = 5;
    alert( f.test );
Свойства функции не стоит путать с переменными и параметрами. Они совершенно никак не связаны. Переменные доступны только внутри функции, они создаются в процессе её выполнения. Это – использование функции «как функции».

А свойство у функции – доступно отовсюду и всегда. Это – использование функции «как объекта».

Если хочется привязать значение к функции, то можно им воспользоваться вместо внешних переменных.

В качестве демонстрации, перепишем пример со счётчиком:

    function makeCounter() {
      function counter() {
        return counter.currentCount++;
      };
      counter.currentCount = 1;

      return counter;
    }

    var counter = makeCounter();
    alert( counter() ); // 1
    alert( counter() ); // 2
При запуске пример работает также.

Принципиальная разница – во внутренней механике и в том, что свойство функции, в отличие от переменной из замыкания – общедоступно, к нему имеет доступ любой, у кого есть объект функции.

Например, можно взять и поменять счётчик из внешнего кода:


    var counter = makeCounter();
    alert( counter() ); // 1

    counter.currentCount = 5;

    alert( counter() ); // 5

===============================================================
Что будет, если вызов say('Вася'); стоит в самом-самом начале, в первой строке кода?

Ошибки не будет, выведет "Вася, undefined".

 
      say('Вася'); // Что выведет? Не будет ли ошибки?

      var phrase = 'Привет';

      function say(name) {
        alert( name + ", " + phrase );
      }

Переменная как таковая существует, вот только на момент запуска функции она равна undefined.

===================================================================
Каков будет результат выполнения этого кода?

    var value = 0;

    function f() {
      if (1) {
        value = true;
      } else {
        var value = false;
      }

      alert( value );
    }

    f();
    
 Результатом будет true, т.к. var обработается и переменная будет создана до выполнения кода.

Соответственно, присвоение value=true сработает на локальной переменной, и alert выведет true.

Внешняя переменная не изменится.

P.S. Если var нет, то в функции переменная не будет найдена. Интерпретатор обратится за ней в window и изменит её там.

Так что без var результат будет также true, но внешняя переменная изменится.

==========================================================================

Каков будет результат выполнения этого кода? Почему?

Результатом будет undefined, затем 5.

     function test() {

      alert( window );

      var window = 5;

      alert( window );
    }

    test();
Такой результат получился потому, что window – это глобальная переменная, но ничто не мешает объявить такую же локальную.

Директива var window обработается до начала выполнения кода функции и будет создана локальная переменная, т.е. свойство LexicalEnvironment.window:

LexicalEnvironment = {
  window: undefined
}
Когда выполнение кода начнется и сработает alert, он выведет уже локальную переменную, которая на тот момент равна undefined.

Затем сработает присваивание, и второй alert выведет уже 5.

============================================================================

Каков будет результат выполнения кода? Почему?

Результат – ошибка. Попробуйте:

     var a = 5

    (function() {
      alert(a)
    })()
Дело в том, что после var a = 5 нет точки с запятой.

JavaScript воспринимает этот код как если бы перевода строки не было:

     var a = 5(function() {
      alert(a)
    })()
То есть, он пытается вызвать функцию 5, что и приводит к ошибке.

Если точку с запятой поставить, все будет хорошо:

     var a = 5;

    (function() {
      alert(a)
    })()
Это один из наиболее частых и опасных подводных камней, приводящих к ошибкам тех, кто не ставит точки с запятой.

=============================================================

Если во внутренней функции есть своя переменная с именем currentCount – можно ли в ней получить currentCount из внешней функции?

    function makeCounter() {
      var currentCount = 1;

      return function() {
        var currentCount;
        // можно ли здесь вывести currentCount из внешней функции (равный 1)?
      };
    }

Нет, нельзя.

Локальная переменная полностью перекрывает внешнюю

===========================================================
Что выведут эти вызовы, если переменная currentCount находится вне makeCounter?

Выведут 1,2,3,4.

Здесь внутренняя функция будет искать – и находить currentCount каждый раз в самом внешнем объекте переменных: глобальном объекте window.

В результате все счётчики будут разделять единое, глобальное текущее значение.

      var currentCount = 1;

      function makeCounter() {
        return function() {
          return currentCount++;
        };
      }

      var counter = makeCounter();
      var counter2 = makeCounter();

      alert( counter() ); // 1
      alert( counter() ); // 2

      alert( counter2() ); // 3
      alert( counter2() ); // 4

==============================================================

[[Scope]] для new Function
Присвоение [[Scope]] для new Function
Есть одно исключение из общего правила присвоения [[Scope]], которое мы рассматривали в предыдущей главе.

При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.

Функции, создаваемые через new Function, имеют значением [[Scope]] не внешний объект переменных, а window.
Следствие – такие функции не могут использовать замыкание. Но это хорошо, так как бережёт от ошибок проектирования, да и при сжатии JavaScript проблем не будет. Если же внешние переменные реально нужны – их можно передать в качестве параметров.

Следующий пример демонстрирует как функция, созданная new Function, игнорирует внешнюю переменную a и выводит глобальную вместо неё:


    var a = 1;

    function getFunc() {
      var a = 2;

      var func = new Function('', 'alert(a)');

      return func;
    }

    getFunc()(); // 1, из window
    
 Сравним с обычным поведением:

    var a = 1;

    function getFunc() {
      var a = 2;

      var func = function() { alert(a); };

      return func;
    }

    getFunc()(); // 2, из LexicalEnvironment функции getFunc
    
==================================================

Счётчик-объект
Ранее мы сделали счётчик.

Напомню, как он выглядел:

     function makeCounter() {
      var currentCount = 1;

      return function() {
        return currentCount++;
      };
    }

    var counter = makeCounter();

    // каждый вызов возвращает результат, увеличивая счётчик
    alert( counter() ); // 1
    alert( counter() ); // 2
    alert( counter() ); // 3
    
 Счётчик получился вполне рабочий, но вот только возможностей ему не хватает. Хорошо бы, чтобы можно было сбрасывать значение счётчика или начинать отсчёт с другого значения вместо 1 или… Да много чего можно захотеть от простого счётчика и, тем более, в более сложных проектах.

Чтобы добавить счётчику возможностей – перейдём с функции на полноценный объект:

     function makeCounter() {
      var currentCount = 1;

      return { // возвратим объект вместо функции
        getNext: function() {
          return currentCount++;
        },

        set: function(value) {
          currentCount = value;
        },

        reset: function() {
          currentCount = 1;
        }
      };
    }

    var counter = makeCounter();

    alert( counter.getNext() ); // 1
    alert( counter.getNext() ); // 2

    counter.set(5);
    alert( counter.getNext() ); // 5
Теперь функция makeCounter возвращает не одну функцию, а объект с несколькими методами:

getNext() – получить следующее значение, то, что раньше делал вызов counter().
set(value) – поставить значение.
reset() – обнулить счётчик.
Все они получают ссылку [[Scope]] на текущий (внешний) объект переменных. Поэтому вызов любого из этих методов будет получать или модифицировать одно и то же внешнее значение currentCount.

Объект счётчика + функция
Изначально, счётчик делался функцией во многом ради красивого вызова: counter(), который увеличивал значение и возвращал результат.

К сожалению, при переходе на объект короткий вызов пропал, вместо него теперь counter.getNext(). Но он ведь был таким простым и удобным…

Поэтому давайте вернём его!

    function makeCounter() {
      var currentCount = 1;

      // возвращаемся к функции
      function counter() {
        return currentCount++;
      }

      // ...и добавляем ей методы!
      counter.set = function(value) {
        currentCount = value;
      };

      counter.reset = function() {
        currentCount = 1;
      };

      return counter;
    }

    var counter = makeCounter();

    alert( counter() ); // 1
    alert( counter() ); // 2

    counter.set(5);
    alert( counter() ); // 5
=========================================================
Напишите функцию sum, которая работает так: sum(a)(b) = a+b.

Да, именно так, через двойные скобки (это не опечатка). Например:

sum(1)(2) = 3
sum(5)(-1) = 4

Чтобы вторые скобки в вызове работали – первые должны возвращать функцию.

Эта функция должна знать про a и уметь прибавлять a к b. Вот так:

     function sum(a) {

      return function(b) {
        return a + b; // возьмет a из внешнего LexicalEnvironment
      };

    }

    alert( sum(1)(2) );
    alert( sum(5)(-1) );
    
    =============================================================
Функция - строковый буфер

В некоторых языках программирования существует объект «строковый буфер», который аккумулирует внутри себя значения. Его функционал состоит из двух возможностей:

Добавить значение в буфер.
Получить текущее содержимое.
Задача – реализовать строковый буфер на функциях в JavaScript, со следующим синтаксисом:

Создание объекта: var buffer = makeBuffer();.
Вызов makeBuffer должен возвращать такую функцию buffer, которая при вызове buffer(value) добавляет значение в некоторое внутреннее хранилище, а при вызове без аргументов buffer() – возвращает его.
Вот пример работы:

function makeBuffer() { /* ваш код */ }

var buffer = makeBuffer();

// добавить значения к буферу
buffer('Замыкания');
buffer(' Использовать');
buffer(' Нужно!');

// получить текущее значение
alert( buffer() ); // Замыкания Использовать Нужно!
Буфер должен преобразовывать все данные к строковому типу:

var buffer = makeBuffer();
buffer(0);
buffer(1);
buffer(0);

alert( buffer() ); // '010'
Решение не должно использовать глобальные переменные.

Текущее значение текста удобно хранить в замыкании, в локальной переменной makeBuffer:
РЕШЕНИЕ:
       function makeBuffer() {
        var text = '';

        return function(piece) {
          if (arguments.length == 0) { // вызов без аргументов
            return text;
          }
          text += piece;
        };
      };

      var buffer = makeBuffer();

      // добавить значения к буферу
      buffer('Замыкания');
      buffer(' Использовать');
      buffer(' Нужно!');
      alert( buffer() ); // 'Замыкания Использовать Нужно!'

      var buffer2 = makeBuffer();
      buffer2(0);
      buffer2(1);
      buffer2(0);

      alert( buffer2() ); // '010'
Начальное значение text = '' – пустая строка. Поэтому операция text += piece прибавляет piece к строке, автоматически преобразуя его к строковому типу, как и требовалось в условии.

=====================================================================

Добавьте буферу из решения задачи Функция - строковый буфер метод buffer.clear(), который будет очищать текущее содержимое буфера:
function makeBuffer() {
  ...ваш код...
}

var buffer = makeBuffer();

buffer("Тест");
buffer(" тебя не съест ");
alert( buffer() ); // Тест тебя не съест

buffer.clear();

alert( buffer() ); // ""


РЕНЕНИЕ:
    function makeBuffer() {
      var text = '';

      function buffer(piece) {
        if (arguments.length == 0) { // вызов без аргументов
          return text;
        }
        text += piece;
      };

      buffer.clear = function() {
        text = "";
      }

      return buffer;
    };

    var buffer = makeBuffer();

    buffer("Тест");
    buffer(" тебя не съест ");
    alert( buffer() ); // Тест тебя не съест

    buffer.clear();

    alert( buffer() ); // ""

========================================================
Сортировка 
У нас есть массив объектов:

    var users = [{
      name: "Вася",
      surname: 'Иванов',
      age: 20
    }, {
      name: "Петя",
      surname: 'Чапаев',
      age: 25
    }, {
      name: "Маша",
      surname: 'Медведева',
      age: 18
    }];

Обычно сортировка по нужному полю происходит так:

    // по полю name (Вася, Маша, Петя)
    users.sort(function(a, b) {
      return a.name > b.name ? 1 : -1;
    });

    // по полю age  (Маша, Вася, Петя)
    users.sort(function(a, b) {
      return a.age > b.age ? 1 : -1;
    });
    
 Мы хотели бы упростить синтаксис до одной строки, вот так:

    users.sort(byField('name'));
    users.forEach(function(user) {
      alert( user.name );
    }); // Вася, Маша, Петя

    users.sort(byField('age'));
    users.forEach(function(user) {
      alert( user.name );
    }); // Маша, Вася, Петя
То есть, вместо того, чтобы каждый раз писать в sort function... – будем использовать byField(...)

Напишите функцию byField(field), которую можно использовать в sort для сравнения объектов по полю field, чтобы пример выше заработал.
    
РЕШЕНИЕ:
      var users = [{
        name: "Вася",
        surname: 'Иванов',
        age: 20
      }, {
        name: "Петя",
        surname: 'Чапаев',
        age: 25
      }, {
        name: "Маша",
        surname: 'Медведева',
        age: 18
      }];

      function byField(field) {
          return function(a, b) {
            return a[field] > b[field] ? 1 : -1;
          }
        }

      users.sort(byField('name'));
      users.forEach(function(user) {
        alert( user.name );
      });

      users.sort(byField('age'));
      users.forEach(function(user) {
        alert( user.name );
      });
      
      
=======================================================================
Фильтрация через функцию
важность: 5
Создайте функцию filter(arr, func), которая получает массив arr и возвращает новый, в который входят только те элементы arr, для которых func возвращает true.
Создайте набор «готовых фильтров»: inBetween(a,b) – «между a,b», inArray([...]) – "в массиве [...]". Использование должно быть таким:
filter(arr, inBetween(3,6)) – выберет только числа от 3 до 6,
filter(arr, inArray([1,2,3])) – выберет только элементы, совпадающие с одним из значений массива.
Пример, как это должно работать:

    /* .. ваш код для filter, inBetween, inArray */
    var arr = [1, 2, 3, 4, 5, 6, 7];

    alert(filter(arr, function(a) {
      return a % 2 == 0
    })); // 2,4,6

    alert( filter(arr, inBetween(3, 6)) ); // 3,4,5,6

    alert( filter(arr, inArray([1, 2, 10])) ); // 1,2


Функция фильтрации
     function filter(arr, func) {
      var result = [];

      for (var i = 0; i < arr.length; i++) {
        var val = arr[i];
        if (func(val)) {
          result.push(val);
        }
      }

      return result;
    }

    var arr = [1, 2, 3, 4, 5, 6, 7];

    alert(filter(arr, function(a) {
      return a % 2 == 0;
    })); // 2, 4, 6

Фильтр inBetween

    function filter(arr, func) {
      var result = [];

      for (var i = 0; i < arr.length; i++) {
        var val = arr[i];
        if (func(val)) {
          result.push(val);
        }
      }

      return result;
    }

    function inBetween(a, b) {
        return function(x) {
          return x >= a && x <= b;
        };
      }

    var arr = [1, 2, 3, 4, 5, 6, 7];
    alert( filter(arr, inBetween(3, 6)) ); // 3,4,5,6
 Фильтр inArray
 
    function filter(arr, func) {
      var result = [];

      for (var i = 0; i < arr.length; i++) {
        var val = arr[i];
        if (func(val)) {
          result.push(val);
        }
      }

      return result;
    }

    function inArray(arr) {
        return function(x) {
          return arr.indexOf(x) != -1;
        };
      }

    var arr = [1, 2, 3, 4, 5, 6, 7];
    alert( filter(arr, inArray([1, 2, 10])) ); // 1,2
===================================================================

Следующий код создает массив функций-стрелков shooters. По замыслу, каждый стрелок должен выводить свой номер:

     function makeArmy() {

      var shooters = [];

      for (var i = 0; i < 10; i++) {
        var shooter = function() { // функция-стрелок
          alert( i ); // выводит свой номер
        };
        shooters.push(shooter);
      }

      return shooters;
    }

    var army = makeArmy();

    army[0](); // стрелок выводит 10, а должен 0
    army[5](); // стрелок выводит 10...
    // .. все стрелки выводят 10 вместо 0,1,2...9
 Почему все стрелки́ выводят одно и то же? Поправьте код, чтобы стрелки работали как задумано. Предложите несколько вариантов исправления.
 ------------------
 Что происходит в этом коде
Функция makeArmy делает следующее:

Создаёт пустой массив shooters:

var shooters = [];
В цикле заполняет массив элементами через shooters.push. При этом каждый элемент массива – это функция, так что в итоге после цикла массив будет таким:

shooters = [
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); }
];
Этот массив возвращается из функции.

Вызов army[5]() – это получение элемента массива (им будет функция), и тут же – её запуск.\
-----------------
Почему ошибка
Вначале разберемся, почему все стрелки выводят одно и то же значение.

В функциях-стрелках shooter отсутствует переменная i. Когда такая функция вызывается, то i она берет из внешнего LexicalEnvironment.

Чему же будет равно это значение i?

К моменту вызова army[0](), функция makeArmy уже закончила работу. Цикл завершился, последнее значение было i=10.

В результате все функции shooter получают из внешнего лексического окружения это, одно и то же, последнее, значение i=10.

Попробуйте исправить проблему самостоятельно.
  ---------------------
  
Исправление (3 варианта)
Есть несколько способов исправить ситуацию.

Первый способ исправить код – это привязать значение непосредственно к функции-стрелку:

 









function makeArmy() {

  var shooters = [];

  for (var i = 0; i < 10; i++) {

    var shooter = function me() {
      alert( me.i );
    };
    shooter.i = i;

    shooters.push(shooter);
  }

  return shooters;
}

var army = makeArmy();

army[0](); // 0
army[1](); // 1
В этом случае каждая функция хранит в себе свой собственный номер.

Кстати, обратите внимание на использование Named Function Expression, вот в этом участке:

...
var shooter = function me() {
  alert( me.i );
};
...
Если убрать имя me и оставить обращение через shooter, то работать не будет:






for (var i = 0; i < 10; i++) {
  var shooter = function() {
    alert( shooter.i ); // вывести свой номер (не работает!)
    // потому что откуда функция возьмёт переменную shooter?
    // ..правильно, из внешнего объекта, а там она одна на всех
  };
  shooter.i = i;
  shooters.push(shooter);
}
Вызов alert(shooter.i) при вызове будет искать переменную shooter, а эта переменная меняет значение по ходу цикла, и к моменту вызова она равна последней функции, созданной в цикле.

Если использовать Named Function Expression, то имя жёстко привязывается к конкретной функции, и поэтому в коде выше me.i возвращает правильный i.

Другое, более продвинутое решение – использовать дополнительную функцию для того, чтобы «поймать» текущее значение i:

 












function makeArmy() {

  var shooters = [];

  for (var i = 0; i < 10; i++) {

    var shooter = (function(x) {

      return function() {
        alert( x );
      };

    })(i);

    shooters.push(shooter);
  }

  return shooters;
}

var army = makeArmy();

army[0](); // 0
army[1](); // 1
Посмотрим выделенный фрагмент более внимательно, чтобы понять, что происходит:

var shooter = (function(x) {
  return function() {
    alert( x );
  };
})(i);
Функция shooter создана как результат вызова промежуточного функционального выражения function(x), которое объявляется – и тут же выполняется, получая x = i.

Так как function(x) тут же завершается, то значение x больше не меняется. Оно и будет использовано в возвращаемой функции-стрелке.

Для красоты можно изменить название переменной x на i, суть происходящего при этом не изменится:

var shooter = (function(i) {
  return function() {
    alert( i );
  };
})(i);
Кстати, обратите внимание – скобки вокруг function(i) не нужны, можно и так:

                                                            var shooter = function(i) { // без скобок вокруг function(i)
  return function() {
    alert( i );
  };
}(i);
Скобки добавлены в код для лучшей читаемости, чтобы человек, который просматривает его, не подумал, что var shooter = function, а понял что это вызов «на месте», и присваивается его результат.

Еще один забавный способ – обернуть весь цикл во временную функцию:

function makeArmy() {

  var shooters = [];

  for (var i = 0; i < 10; i++)(function(i) {

    var shooter = function() {
      alert( i );
    };

    shooters.push(shooter);

  })(i);

  return shooters;
}

var army = makeArmy();

army[0](); // 0
army[1](); // 1
Вызов (function(i) { ... }) обернут в скобки, чтобы интерпретатор понял, что это Function Expression.

Плюс этого способа – в большей читаемости. Фактически, мы не меняем создание shooter, а просто обертываем итерацию в функцию.

Открыть решение с тестами в песочнице.
 
